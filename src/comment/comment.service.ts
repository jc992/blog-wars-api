import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { CreateCommentDto } from './dto/createComment.dto';
import { UpdateCommentDto } from './dto/updateComment.dto';
import { UserService } from '../user/user.service';
import { EncryptionService } from '../encryption/encryption.service';
import { Comment } from './entities/comment.entity';
import { Repository } from 'typeorm';
import { InjectRepository } from '@nestjs/typeorm';
import { BlogPostService } from '../blogPost/blogPost.service';
import { CommentModel } from './dto/commentModel.dto';

@Injectable()
export class CommentService {
  constructor(
    private userService: UserService,
    private blogPostService: BlogPostService,
    private encryptionService: EncryptionService,
    @InjectRepository(Comment) private repo: Repository<Comment>,
  ) {}

  async create({ blogPostId, content }: CreateCommentDto, userId: number): Promise<any> {
    await this.checkUserAndPostExistOrThrow(userId, blogPostId);
    const encryptedContent = await this.encryptionService.encrypt(content);

    return this.repo.insert({
      content: encryptedContent,
      userId,
      blogPostId,
    });
  }

  async findOne(id: number): Promise<Comment> {
    const comment = await this.repo.findOneBy({ id });
    if (!comment) {
      throw new HttpException('comment not found', HttpStatus.NOT_FOUND);
    }
    return this.decryptComment(comment);
  }

  async findByUserId(userId: number): Promise<CommentModel[]> {
    const comments = await this.repo
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.user', 'user')
      .where(`comment.userId = ${userId}`)
      .getMany();
    return Promise.all(comments.map(async (c) => new CommentModel(await this.decryptComment(c))));
  }

  async findByBlogPostId(blogPostId: number): Promise<CommentModel[]> {
    const comments = await this.repo
      .createQueryBuilder('comment')
      .leftJoinAndSelect('comment.user', 'user')
      .where(`comment.blogPostId = ${blogPostId}`)
      .getMany();
    return Promise.all(comments.map(async (c) => new CommentModel(await this.decryptComment(c))));
  }

  async update(id: number, dto: UpdateCommentDto) {
    // TODO: add verification to check if jwt token is generated by this same user trying to update the comment
    await this.findOne(id);
    const newEncryptedContent = await this.encryptionService.encrypt(dto.content);
    return this.repo.update(id, { content: newEncryptedContent });
  }

  async remove(id: number) {
    // TODO: add verification to check if jwt token is generated by this same user trying to delete the comment
    await this.findOne(id);
    return this.repo.delete(id);
  }

  private async checkUserAndPostExistOrThrow(userId: number, blogPostId: number) {
    const [user, post] = await Promise.all([
      this.userService.getUserById(userId),
      this.blogPostService.findById(blogPostId),
    ]);

    if (!user) {
      throw new HttpException('user not found', HttpStatus.NOT_FOUND);
    }

    if (!post) {
      throw new HttpException('blog post not found', HttpStatus.NOT_FOUND);
    }
  }

  private async decryptComment(comment: Comment): Promise<Comment> {
    const decryptedContent = await this.encryptionService.decrypt(comment.content);
    return {
      ...comment,
      content: decryptedContent,
    };
  }
}
